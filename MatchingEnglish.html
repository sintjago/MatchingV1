<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matching Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f4f4f4;
            height: 100vh;
        }
        canvas {
            border: 1px solid #333;
            background-color: #fff;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
            width: 100%;
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .buttons {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            gap: 5px;
        }
        .container textarea {
            width: 90%;
            max-width: 600px;
            height: 80px;
            resize: none;
            padding: 10px;
            font-family: monospace;
        }
        .container button {
            padding: 8px 15px;
            background-color: #333;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        .container button:hover {
            background-color: #555;
        }
        .instructions {
            font-size: 14px;
            color: #666;
            margin-left: 10px;
        }
        .pair-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            gap: 5px;
        }
        .timer-container {
            display: flex;
            align-items: center;
            margin-left: 10px;
            gap: 5px;
        }
        .timer-container input {
            width: 70px;
            padding: 5px;
            text-align: center;
        }
        @media (max-width: 768px) {
            canvas {
                width: 90%;
                height: 300px;
            }
            .container textarea {
                height: 60px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="controls">
        <div class="instructions">Find the pairs. Click a card to flip. Drag to move.</div>
    </div>

    <div class="pair-controls">
        <button id="add1-btn">+1 Pair</button>
        <button id="add5-btn">+5 Pairs</button>
        <button id="remove1-btn">-1 Pair</button>
        <button id="remove5-btn">-5 Pairs</button>
        <button id="shuffle-btn">Shuffle</button>
        <button id="grid-btn">Grid</button>
        <button id="reset-btn">Reset</button>
        <div class="timer-container">
            <input id="timer-input" type="text" value="01:00">
            <button id="start-timer-btn">Start</button>
            <button id="stop-timer-btn">Stop</button>
        </div>
    </div>

    <div class="container">
        <textarea id="json-input" placeholder='Enter JSON format here (e.g., [{"term": "Dog", "definition": "A loyal domestic animal."}])'></textarea>
        <button id="update-cards-btn">Update Cards</button>
        <p>Only 5 pairs are added at random to start.</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = Math.min(window.innerWidth * 0.8, 600);
        canvas.height = Math.min(window.innerHeight * 0.6, 400);

        const cardWidth = 120;
        const cardHeight = 80;
        const padding = 10;
        const distinctColors = [
            '#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#33FFF3', '#FF8C33', '#8C33FF', '#33FF8C', '#FF3333', '#3333FF',
            '#A1FF33', '#FF5733', '#33A1FF', '#FF33FF', '#33FFA1', '#5733FF', '#FF33A1', '#F3FF33', '#FF8CFF', '#8CFF33'
        ];
        let cards = [];
        let availablePairs = [
            { term: "Dog", definition: "A loyal domesticated animal commonly kept as a pet." },
            { term: "Mountain", definition: "A large natural elevation of the earth's surface." },
            { term: "Ocean", definition: "A vast body of salt water that covers most of the Earth's surface." },
            { term: "Tree", definition: "A tall plant with a trunk and branches made of wood." },
            { term: "Sky", definition: "The expanse above us where clouds and the sun appear." },
            { term: "Flower", definition: "The part of a plant that is often colorful and produces seeds." },
            { term: "River", definition: "A large natural stream of water flowing in a channel." },
            { term: "Lake", definition: "A sizable inland body of standing water." },
            { term: "Snow", definition: "Frozen water crystals that fall from the sky in cold weather." },
            { term: "Sun", definition: "The star at the center of our solar system that gives us light." }
        ];
        let selectedPairs = [];
        let selectedCards = [];
        let draggingCard = null;
        let offsetX, offsetY;
        let matchedPairs = 0;
        let topZIndex = 0;
        let lockFlip = false;
        let timerInterval = null;
        let timeRemaining = 60;

        const synth = window.speechSynthesis;

        class Card {
            constructor(text, x, y, fullText, isTerm = false) {
                this.text = text;
                this.fullText = fullText;
                this.x = x;
                this.y = y;
                this.width = cardWidth;
                this.height = cardHeight;
                this.isFlipped = false;
                this.isMatched = false;
                this.isTerm = isTerm;
                this.matchColor = null;
                this.showFullText = false;
                this.zIndex = topZIndex++;
            }

            draw() {
                ctx.save();
                ctx.fillStyle = this.isMatched && this.matchColor ? this.matchColor :
                                this.isFlipped ? "#FFD700" : "#aaa";
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                if (this.isFlipped || this.isMatched) {
                    ctx.fillStyle = "#000";
                    ctx.font = "12px Arial";
                    ctx.textAlign = "left";
                    ctx.textBaseline = "top";
                    const method = this.showFullText ? this.drawFullText : this.drawText;
                    method.call(this, ctx, this.text, this.x + padding, this.y + padding, this.width - 2 * padding);
                }
                ctx.restore();
            }

            drawText(context, text, x, y, maxWidth) {
                const words = text.split(' ');
                let line = '', lineHeight = 14;
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    if (context.measureText(testLine).width > maxWidth && n > 0) {
                        context.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                        if (y + lineHeight > this.y + this.height - padding) {
                            context.fillText(line.trim() + '...', x, y);
                            return;
                        }
                    } else line = testLine;
                }
                context.fillText(line, x, y);
            }

            drawFullText(context, text, x, y, maxWidth) {
                const words = text.split(' ');
                let line = '', lineHeight = 14;
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    if (context.measureText(testLine).width > maxWidth && n > 0) {
                        context.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    } else line = testLine;
                }
                context.fillText(line, x, y);
            }

            contains(mx, my) {
                return mx > this.x && mx < this.x + this.width && my > this.y && my < this.y + this.height;
            }

            flip() {
                if (!this.isMatched && !this.isFlipped) {
                    this.isFlipped = true;
                    return true;
                }
                return false;
            }

            toggleFullText() {
                this.showFullText = !this.showFullText;
            }

            speak() {
                const utterance = new SpeechSynthesisUtterance(this.text);
                utterance.lang = "en-US";
                synth.cancel();
                synth.speak(utterance);
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function addPairs(count) {
            const remainingPairs = availablePairs.filter(p => !selectedPairs.includes(p));
            shuffleArray(remainingPairs);
            const pairsToAdd = remainingPairs.slice(0, count);
            pairsToAdd.forEach(pair => {
                cards.push(new Card(pair.term, Math.random() * (canvas.width - cardWidth), Math.random() * (canvas.height - cardHeight), pair.term, true));
                cards.push(new Card(pair.definition.slice(0, 50) + '...', Math.random() * (canvas.width - cardWidth), Math.random() * (canvas.height - cardHeight), pair.definition, false));
                selectedPairs.push(pair);
            });
            draw();
        }

        function removePairs(count) {
            const toRemove = selectedPairs.splice(-count, count);
            toRemove.forEach(pair => {
                cards = cards.filter(c => c.fullText !== pair.term && c.fullText !== pair.definition);
            });
            draw();
        }

        function shuffleCards() {
            cards.forEach(c => {
                c.x = Math.random() * (canvas.width - cardWidth);
                c.y = Math.random() * (canvas.height - cardHeight);
            });
            draw();
        }

        function arrangeGrid() {
            const cols = Math.floor(canvas.width / (cardWidth + padding));
            let x = padding, y = padding;
            cards.forEach((card, i) => {
                card.x = x;
                card.y = y;
                x += cardWidth + padding;
                if ((i + 1) % cols === 0) {
                    x = padding;
                    y += cardHeight + padding;
                }
            });
            draw();
        }

        function resetGame() {
            selectedCards = [];
            matchedPairs = 0;
            cards.forEach(card => {
                card.isFlipped = false;
                card.isMatched = false;
                card.matchColor = null;
            });
            shuffleCards();
        }

        function checkMatch() {
            if (selectedCards.length === 2) {
                const [first, second] = selectedCards;
                if (first.isTerm !== second.isTerm) {
                    const f = availablePairs.find(p => p.term === first.text || p.definition === first.fullText);
                    const s = availablePairs.find(p => p.term === second.text || p.definition === second.fullText);
                    if (f && s && f.term === s.term) {
                        const color = distinctColors[matchedPairs % distinctColors.length];
                        first.isMatched = second.isMatched = true;
                        first.matchColor = second.matchColor = color;
                        matchedPairs++;
                        lockFlip = false;
                    } else {
                        setTimeout(() => {
                            first.isFlipped = second.isFlipped = false;
                            draw();
                            lockFlip = false;
                        }, 1000);
                    }
                } else {
                    setTimeout(() => {
                        first.isFlipped = second.isFlipped = false;
                        draw();
                        lockFlip = false;
                    }, 1000);
                }
                selectedCards = [];
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            cards.sort((a, b) => a.zIndex - b.zIndex);
            cards.forEach(c => c.draw());
        }

        function startTimer() {
            const [min, sec] = document.getElementById("timer-input").value.split(":").map(Number);
            timeRemaining = min * 60 + sec;
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    alert("Time's up!");
                } else {
                    timeRemaining--;
                    const m = String(Math.floor(timeRemaining / 60)).padStart(2, '0');
                    const s = String(timeRemaining % 60).padStart(2, '0');
                    document.getElementById("timer-input").value = `${m}:${s}`;
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) clearInterval(timerInterval);
        }

        canvas.addEventListener('mousedown', (e) => {
            if (lockFlip) return;
            const mx = e.clientX - canvas.offsetLeft;
            const my = e.clientY - canvas.offsetTop;
            for (const card of cards) {
                if (card.contains(mx, my)) {
                    draggingCard = card;
                    offsetX = mx - card.x;
                    offsetY = my - card.y;
                    card.zIndex = topZIndex++;
                    if (card.flip()) {
                        selectedCards.push(card);
                        card.speak();
                        if (selectedCards.length === 2) {
                            lockFlip = true;
                            checkMatch();
                        }
                    } else if (card.isMatched) card.speak();
                    break;
                }
            }
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggingCard) {
                const mx = e.clientX - canvas.offsetLeft;
                const my = e.clientY - canvas.offsetTop;
                draggingCard.x = mx - offsetX;
                draggingCard.y = my - offsetY;
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggingCard = null;
        });

        document.getElementById('add1-btn').addEventListener('click', () => addPairs(1));
        document.getElementById('add5-btn').addEventListener('click', () => addPairs(5));
        document.getElementById('remove1-btn').addEventListener('click', () => removePairs(1));
        document.getElementById('remove5-btn').addEventListener('click', () => removePairs(5));
        document.getElementById('shuffle-btn').addEventListener('click', () => shuffleCards());
        document.getElementById('grid-btn').addEventListener('click', () => arrangeGrid());
        document.getElementById('reset-btn').addEventListener('click', () => resetGame());
        document.getElementById('start-timer-btn').addEventListener('click', () => startTimer());
        document.getElementById('stop-timer-btn').addEventListener('click', () => stopTimer());

        document.getElementById('update-cards-btn').addEventListener('click', () => {
            const jsonInput = document.getElementById('json-input').value;
            try {
                const newPairs = JSON.parse(jsonInput);
                availablePairs = newPairs;
                selectedPairs = [];
                cards = [];
                addPairs(5);
            } catch (e) {
                alert("Invalid JSON format. Please check your input.");
            }
        });

        addPairs(5);

        window.addEventListener('resize', () => {
            canvas.width = Math.min(window.innerWidth * 0.8, 600);
            canvas.height = Math.min(window.innerHeight * 0.6, 400);
            draw();
        });
    </script>
</body>
</html>
